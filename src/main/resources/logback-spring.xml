<!-- 컨테이너 환경에서는 파일 감시 불필요: scan="false" 권장 -->
<configuration scan="false">

  <!-- 로그 레벨 설정 -->
  <springProperty scope="context" name="LOG_LEVEL" source="logging.level.root" defaultValue="INFO"/>

  <!-- 콘솔 출력 Appender -->
  <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <!-- 날짜, requestId(MDC), 로그레벨, 로거명, 메시지 -->
      <pattern>%d{yyyy-MM-dd HH:mm:ss} [%X{requestId}] %-5level %logger{36} - %msg%n</pattern>
      <charset>UTF-8</charset>
    </encoder>
  </appender>

  <!-- 롤링 파일 Appender: 일반 애플리케이션 로그 -->
  <appender name="APP_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <!-- 활성 로그 파일 경로 -->
    <file>logs/app.log</file>
    <append>true</append>
    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
      <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%X{requestId}] %-5level %logger - %msg%n</pattern>
    </encoder>

    <!-- 크기+날짜 기반 롤링, gzip 압축 -->
    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
      <!-- 일자별 + 인덱스, gzip 압축 -->
      <fileNamePattern>logs/app.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
      <!-- 개별 파일 최대 크기 -->
      <maxFileSize>100MB</maxFileSize>
      <!-- 전체 보관 용량 상한 (초과 시 오래된 파일부터 삭제) -->
      <totalSizeCap>10GB</totalSizeCap>
      <!-- 보관 일수 -->
      <maxHistory>30</maxHistory>
      <cleanHistoryOnStart>true</cleanHistoryOnStart>
    </rollingPolicy>
  </appender>

  <!-- 비동기 래퍼: I/O 병목 완화 -->
  <appender name="ASYNC_APP_FILE" class="ch.qos.logback.classic.AsyncAppender">
    <queueSize>8192</queueSize>
    <discardingThreshold>0</discardingThreshold>
    <neverBlock>true</neverBlock>
    <appender-ref ref="APP_FILE"/>
  </appender>

  <!-- ERROR 전용 파일 (문제 발생 시 신속 추적) -->
  <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>logs/app-error.log</file>
    <append>true</append>
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      <level>ERROR</level>
    </filter>
    <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
      <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%X{requestId}] %-5level %logger - %msg%n</pattern>
    </encoder>
    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
      <fileNamePattern>logs/app-error.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
      <maxFileSize>50MB</maxFileSize>
      <totalSizeCap>5GB</totalSizeCap>
      <maxHistory>60</maxHistory>
    </rollingPolicy>
  </appender>

  <!-- MethodLoggingAspect의 로그가 Sentry로 전송되지 않도록 설정 -->
  <logger name="akuma.whiplash.global.log.MethodLoggingAspect" level="INFO" additivity="false">
    <appender-ref ref="CONSOLE"/>
    <!-- 필요하면 파일에도 남기고 싶을 때 아래 줄을 추가 -->
    <appender-ref ref="ASYNC_APP_FILE"/>
  </logger>

  <!-- [KEEP/OPT] Sentry Appender -->
  <appender name="SENTRY" class="io.sentry.logback.SentryAppender">
    <!-- [OPT] DSN이 application.yml에 없다면 환경변수로 주입 가능
         <dsn>${SENTRY_DSN}</dsn>
    -->
    <!-- ERROR 레벨 이상의 로그만 Sentry로 전송 -->
    <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
      <level>ERROR</level>
    </filter>
  </appender>

  <!-- root 로거: 파일/에러/Sentry 모두 연결 -->
  <root level="${LOG_LEVEL}">
    <appender-ref ref="CONSOLE"/>
    <appender-ref ref="ASYNC_APP_FILE"/>   <!-- [ADD] 일반 로그 파일 -->
    <appender-ref ref="ERROR_FILE"/>       <!-- [ADD] 에러 전용 파일 -->
    <appender-ref ref="SENTRY"/>           <!-- [KEEP] Sentry ERROR↑ -->
  </root>

</configuration>
